

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/star.png">
  <link rel="icon" href="/img/star.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#0000008">
  <meta name="author" content="Zubeneschamali">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. 原型&amp;原型链1.1. 构造函数创建对象我们先使用构造函数创建一个对象： 1234function Person() &amp;#123;&amp;#125;var person &#x3D; new Person();person.name &#x3D; &amp;#x27;zube&amp;#x27;;console.log(person.name)  在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高级用法">
<meta property="og:url" content="http://example.com/2023/03/20/JS%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/index.html">
<meta property="og:site_name" content="Zubeneschamali&#39;s Block">
<meta property="og:description" content="1. 原型&amp;原型链1.1. 构造函数创建对象我们先使用构造函数创建一个对象： 1234function Person() &amp;#123;&amp;#125;var person &#x3D; new Person();person.name &#x3D; &amp;#x27;zube&amp;#x27;;console.log(person.name)  在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/js_proto.png">
<meta property="og:image" content="http://example.com/image/js_proto_1.png">
<meta property="og:image" content="http://example.com/image/js_proto_1.png">
<meta property="og:image" content="http://example.com/image/js_proto_3.png">
<meta property="og:image" content="http://example.com/image/js_proto_4.png">
<meta property="article:published_time" content="2023-03-20T06:24:16.000Z">
<meta property="article:modified_time" content="2023-03-20T12:19:30.699Z">
<meta property="article:author" content="Zubeneschamali">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/image/js_proto.png">
  
  
  
  <title>JS高级用法 - Zubeneschamali&#39;s Block</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Zubeneschamali</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JS高级用法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-20 14:24" pubdate>
          2023年3月20日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          355 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JS高级用法</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-原型-amp-原型链"><a href="#1-原型-amp-原型链" class="headerlink" title="1. 原型&amp;原型链"></a>1. 原型&amp;原型链</h1><h2 id="1-1-构造函数创建对象"><a href="#1-1-构造函数创建对象" class="headerlink" title="1.1. 构造函数创建对象"></a>1.1. 构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zube&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>) <br></code></pre></td></tr></table></figure>
<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>
<h2 id="1-2-prototype"><a href="#1-2-prototype" class="headerlink" title="1.2. prototype"></a>1.2. prototype</h2><p>每个函数都有一个 prototype 属性，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-comment">// 虽然写在注释里，但是你要注意：</span><br><span class="hljs-comment">// prototype是函数才会有的属性</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zube&#x27;</span>;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>) <span class="hljs-comment">// zube</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">name</span>) <span class="hljs-comment">// zube</span><br></code></pre></td></tr></table></figure>
<p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？<br>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。<br>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。<br>用一张图表示构造函数和实例原型之间的关系：<br><img src="/image/js_proto.png" srcset="/img/loading.gif" lazyload alt="构造函数和实例原型之间的关系"><br>这里用 Object.prototype 表示实例原型。<br>那么该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢？</p>
<h2 id="1-3-proto"><a href="#1-3-proto" class="headerlink" title="1.3. proto"></a>1.3. <strong>proto</strong></h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p><img src="/image/js_proto_1.png" srcset="/img/loading.gif" lazyload alt="构造函数和实例原型之间的关系"><br>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h2 id="1-4-constructor"><a href="#1-4-constructor" class="headerlink" title="1.4. constructor"></a>1.4. constructor</h2><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数是有的：constructor，每个原型都有一个 constructor 属性指向关联的构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p><img src="/image/js_proto_1.png" srcset="/img/loading.gif" lazyload alt="构造函数和实例原型之间的关系"><br>所以，这里可以得到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span> == <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Person</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h2 id="1-5-实例与原型"><a href="#1-5-实例与原型" class="headerlink" title="1.5. 实例与原型"></a>1.5. 实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zube&#x27;</span>;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;bezu&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>) <span class="hljs-comment">// bezu</span><br><br><span class="hljs-keyword">delete</span> person.<span class="hljs-property">name</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>) <span class="hljs-comment">// zube</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 bezu。<br>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，结果为 zube。</p>
<h2 id="1-6-原型的原型"><a href="#1-6-原型的原型" class="headerlink" title="1.6. 原型的原型"></a>1.6. 原型的原型</h2><p>如果在原型上还没有找到呢？原型的原型又是什么呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zube&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>) <span class="hljs-comment">// zube</span><br>其实原型对象就是通过 <span class="hljs-title class_">Object</span> 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图：<br></code></pre></td></tr></table></figure>
<p><img src="/image/js_proto_3.png" srcset="/img/loading.gif" lazyload alt="构造函数和实例原型之间的关系"></p>
<h2 id="1-7-原型链"><a href="#1-7-原型链" class="headerlink" title="1.7. 原型链"></a>1.7. 原型链</h2><p>那 Object.prototype 的原型呢？<br>null，我们可以打印：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>然而 null 究竟代表了什么呢？<br>null 表示“没有对象”，即该处不应该有值。<br>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。<br>所以查找属性的时候查到 Object.prototype 就可以停止查找了。<br>最后一张关系图也可以更新为：<br><img src="/image/js_proto_4.png" srcset="/img/loading.gif" lazyload alt="构造函数和实例原型之间的关系"><br>其中，蓝色为原型链</p>
<h2 id="1-8-其他"><a href="#1-8-其他" class="headerlink" title="1.8. 其他"></a>1.8. 其他</h2><h3 id="1-14-1-constructor"><a href="#1-14-1-constructor" class="headerlink" title="1.14.1. constructor"></a>1.14.1. constructor</h3><p>首先是 constructor 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：<br>person.constructor === Person.prototype.constructor</p>
<h3 id="1-14-2-proto"><a href="#1-14-2-proto" class="headerlink" title="1.14.2. proto"></a>1.14.2. <strong>proto</strong></h3><p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="1-14-3-继承"><a href="#1-14-3-继承" class="headerlink" title="1.14.3. 继承"></a>1.14.3. 继承</h3><p>关于继承，前面提到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：<br>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
<h1 id="2-词法作用域和动态作用域"><a href="#2-词法作用域和动态作用域" class="headerlink" title="2. 词法作用域和动态作用域"></a>2. 词法作用域和动态作用域</h1><h2 id="2-1-作用域"><a href="#2-1-作用域" class="headerlink" title="2.1. 作用域"></a>2.1. 作用域</h2><p>作用域是指程序源代码中定义变量的区域。<br>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。<br>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<h2 id="2-2-静态作用域和动态作用域"><a href="#2-2-静态作用域和动态作用域" class="headerlink" title="2.2. 静态作用域和动态作用域"></a>2.2. 静态作用域和动态作用域</h2><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。<br>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">bar</span>();<br><br><span class="hljs-comment">// 结果是 ???</span><br></code></pre></td></tr></table></figure>
<p>假设JavaScript采用静态作用域，让我们分析下执行过程：<br>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。<br>假设JavaScript采用动态作用域，让我们分析下执行过程：<br>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。<br>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p>
<h2 id="2-3-动态作用域"><a href="#2-3-动态作用域" class="headerlink" title="2.3. 动态作用域"></a>2.3. 动态作用域</h2><p>什么语言是动态作用域？<br>bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">value=1<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span> () &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$value</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">bar</span></span> () &#123;<br>    <span class="hljs-built_in">local</span> value=2;<br>    foo;<br>&#125;<br>bar<br></code></pre></td></tr></table></figure>
<p>2.4. 思考<br>看一个面试题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// case 1</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br><br><span class="hljs-comment">// case 2</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-title function_">checkscope</span>()();<br></code></pre></td></tr></table></figure>
<p>两段代码各自的执行结果是多少？<br>local scope<br>因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。<br>而引用《JavaScript权威指南》的回答就是：<br>JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。<br>但是在这里真正想让大家思考的是：<br>虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？</p>
<h1 id="3-执行上下文"><a href="#3-执行上下文" class="headerlink" title="3. 执行上下文"></a>3. 执行上下文</h1><h2 id="3-1-顺序执行"><a href="#3-1-顺序执行" class="headerlink" title="3.1. 顺序执行"></a>3.1. 顺序执行</h2><p>写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo1&#x27;</span>);<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// foo1</span><br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo2&#x27;</span>);<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// foo2</span><br></code></pre></td></tr></table></figure>
<p>那这段呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo1&#x27;</span>);<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// foo2</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo2&#x27;</span>);<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// foo2</span><br></code></pre></td></tr></table></figure>
<p>打印的结果却是两个 foo2。<br>这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，那这个“一段一段”中的“段”究竟是怎么划分的呢？<br>到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)); <span class="hljs-comment">//输出2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add2</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));  <span class="hljs-comment">//报错：add1 is not a function</span><br><span class="hljs-keyword">var</span> add1 = <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-comment">// 用函数语句创建的函数add2，函数名称和函数体均被提前，在声明它之前就使用它。</span><br><span class="hljs-comment">// 但是使用var表达式定义函数add1，只有变量声明提前了，变量初始化代码仍然在原来的位置，没法提前执行。</span><br></code></pre></td></tr></table></figure>
<h2 id="3-2-可执行代码"><a href="#3-2-可执行代码" class="headerlink" title="3.2. 可执行代码"></a>3.2. 可执行代码</h2><p>这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？<br>其实很简单，就三种，全局代码、函数代码、eval代码。<br>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p>
<h2 id="3-3-执行上下文栈"><a href="#3-3-执行上下文栈" class="headerlink" title="3.3. 执行上下文栈"></a>3.3. 执行上下文栈</h2><p>JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文<br>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span> = [];<br></code></pre></td></tr></table></figure>
<p>试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span> = [<br>    globalContext<br>];<br></code></pre></td></tr></table></figure>
<p> 当JavaScript 遇到下面的这段代码了：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun3</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fun3&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fun3</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fun2</span>();<br>&#125;<br><br><span class="hljs-title function_">fun1</span>();<br></code></pre></td></tr></table></figure><br>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 伪代码</span><br><br><span class="hljs-comment">// fun1()</span><br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;fun1&gt; functionContext);<br><span class="hljs-comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文</span><br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;fun2&gt; functionContext);<br><br><span class="hljs-comment">// 擦，fun2还调用了fun3！</span><br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;fun3&gt; functionContext);<br><br><span class="hljs-comment">// fun3执行完毕</span><br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><br><span class="hljs-comment">// fun2执行完毕</span><br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><br><span class="hljs-comment">// fun1执行完毕</span><br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><br><span class="hljs-comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span><br></code></pre></td></tr></table></figure></p>
<h2 id="3-4-回顾上文"><a href="#3-4-回顾上文" class="headerlink" title="3.4. 回顾上文"></a>3.4. 回顾上文</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// case 1</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br><br><span class="hljs-comment">// case 2</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-title function_">checkscope</span>()();<br></code></pre></td></tr></table></figure>
<p>两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？<br>答案就是执行上下文栈的变化不一样。<br>模拟第一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;checkscope&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;f&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br></code></pre></td></tr></table></figure>
<p>模拟第二段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;checkscope&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;f&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br></code></pre></td></tr></table></figure>
<p>这就是上文说到的区别。</p>
<h1 id="4-变量对象"><a href="#4-变量对象" class="headerlink" title="4. 变量对象"></a>4. 变量对象</h1><h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1. 基础"></a>4.1. 基础</h2><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。<br>对于每个执行上下文，都有三个重要属性：<br>● 变量对象(Variable object，VO)；<br>● 作用域链(Scope chain)；<br>● this；<br>这里着重讲变量对象的内容</p>
<h2 id="4-2-变量对象"><a href="#4-2-变量对象" class="headerlink" title="4.2. 变量对象"></a>4.2. 变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。<br>因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。</p>
<h2 id="4-3-全局上下文"><a href="#4-3-全局上下文" class="headerlink" title="4.3. 全局上下文"></a>4.3. 全局上下文</h2><ol>
<li>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。</li>
<li>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</li>
<li>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。<br>简单点说:<br>(1) 可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br></code></pre></td></tr></table></figure>
(2) 全局对象是由 Object 构造函数实例化的一个对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);<br></code></pre></td></tr></table></figure>
(3) 预定义的属性是否可用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">Math</span>.<span class="hljs-title function_">random</span>());<br></code></pre></td></tr></table></figure>
(4) 作为全局变量的宿主<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br></code></pre></td></tr></table></figure>
(5) 客户端 JavaScript 中，全局对象有 window 属性指向自身<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">window</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>);<br></code></pre></td></tr></table></figure>
综上，对JS而言，全局上下文中的变量对象就是全局对象。</li>
</ol>
<h2 id="4-4-函数上下文"><a href="#4-4-函数上下文" class="headerlink" title="4.4. 函数上下文"></a>4.4. 函数上下文</h2><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。<br>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。<br>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p>
<h2 id="4-5-执行过程"><a href="#4-5-执行过程" class="headerlink" title="4.5. 执行过程"></a>4.5. 执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：<br>(1)进入执行上下文；<br>(2)代码执行；</p>
<h3 id="4-5-1-进入执行上下文"><a href="#4-5-1-进入执行上下文" class="headerlink" title="4.5.1. 进入执行上下文"></a>4.5.1. 进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，<br>变量对象会包括：<br>(1)函数的所有形参 (如果是函数上下文)<br>  ○ 由名称和对应值组成的一个变量对象的属性被创建；<br>  ○ 没有实参，属性值设为 undefined；<br>(2)函数声明<br>  ○ 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；<br>  ○ 如果变量对象已经存在相同名称的属性，则完全替换这个属性；<br>(3)变量声明<br>  ○ 由名称和对应值（undefined）组成一个变量对象的属性被创建；<br>  ○ 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性；<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br>  b = <span class="hljs-number">3</span>;<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">AO</span> = &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>    &#125;,<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>    <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>    <span class="hljs-attr">d</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-5-2-代码执行"><a href="#4-5-2-代码执行" class="headerlink" title="4.5.2. 代码执行"></a>4.5.2. 代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值<br>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">AO</span> = &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>    &#125;,<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>    <span class="hljs-attr">d</span>: reference to <span class="hljs-title class_">FunctionExpression</span> <span class="hljs-string">&quot;d&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ol>
<li>全局上下文的变量对象初始化是全局对象；</li>
<li>函数上下文的变量对象初始化只包括 Arguments 对象；</li>
<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值；</li>
<li>在代码执行阶段，会再次修改变量对象的属性值；</li>
</ol>
<h3 id="4-5-3-思考题"><a href="#4-5-3-思考题" class="headerlink" title="4.5.3. 思考题"></a>4.5.3. 思考题</h3><p>example 1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    a = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// ???</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    a = <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ???</span><br></code></pre></td></tr></table></figure>
<p>第一段会报错：Uncaught ReferenceError: a is not defined。<br>第二段会打印：1。<br>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。<br>第一段执行 console 的时候， AO 的值是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">AO</span> = &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>        <span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。<br>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。<br>example 2</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>会打印函数，而不是 undefined 。<br>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<h1 id="5-作用域链"><a href="#5-作用域链" class="headerlink" title="5. 作用域链"></a>5. 作用域链</h1><p>上文讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。<br>对于每个执行上下文，都有三个重要属性：<br>● 变量对象(Variable object，VO)<br>● 作用域链(Scope chain)<br>● this<br>本节讲作用域链。</p>
<h2 id="5-1-作用域链"><a href="#5-1-作用域链" class="headerlink" title="5.1. 作用域链"></a>5.1. 作用域链</h2><p>上节讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<h2 id="5-2-函数创建"><a href="#5-2-函数创建" class="headerlink" title="5.2. 函数创建"></a>5.2. 函数创建</h2><p>上文的词法作用域与动态作用域中讲到，函数的作用域在函数定义的时候就决定了。<br>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数创建时，各自的[[scope]]为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">foo.[[scope]] = [<br>  globalContext.<span class="hljs-property">VO</span><br>];<br><br>bar.[[scope]] = [<br>    fooContext.<span class="hljs-property">AO</span>,<br>    globalContext.<span class="hljs-property">VO</span><br>];<br></code></pre></td></tr></table></figure>
<h2 id="5-3-函数激活"><a href="#5-3-函数激活" class="headerlink" title="5.3. 函数激活"></a>5.3. 函数激活</h2><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。<br>这时候执行上下文的作用域链，我们命名为 Scope：<br>Scope = [AO].concat([[Scope]]);<br>至此，作用域链创建完毕。</p>
<h2 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4. 总结"></a>5.4. 总结</h2><p>结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope2 = <span class="hljs-string">&#x27;local scope&#x27;</span>;<br>    <span class="hljs-keyword">return</span> scope2;<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br></code></pre></td></tr></table></figure>
<p>执行过程如下：<br>1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscope.[[scope]] = [<br>    globalContext.<span class="hljs-property">VO</span><br>];<br></code></pre></td></tr></table></figure>
<p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span> = [<br>    checkscopeContext,<br>    globalContext<br>];<br></code></pre></td></tr></table></figure>
<p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链<br>checkscopeContext = {<br>    Scope: checkscope.[[scope]],<br>}<br>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscopeContext = &#123;<br>    <span class="hljs-attr">AO</span>: &#123;<br>        <span class="hljs-attr">arguments</span>: &#123;<br>            <span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>        &#125;,<br>        <span class="hljs-attr">scope2</span>: <span class="hljs-literal">undefined</span><br>    &#125;，<br>    <span class="hljs-title class_">Scope</span>: checkscope.[[scope]],<br>&#125;<br></code></pre></td></tr></table></figure>
<p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscopeContext = &#123;<br>    <span class="hljs-attr">AO</span>: &#123;<br>        <span class="hljs-attr">arguments</span>: &#123;<br>            <span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>        &#125;,<br>        <span class="hljs-attr">scope2</span>: <span class="hljs-literal">undefined</span><br>    &#125;,<br>    <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>, [[<span class="hljs-title class_">Scope</span>]]]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscopeContext = &#123;<br>    <span class="hljs-attr">AO</span>: &#123;<br>        <span class="hljs-attr">arguments</span>: &#123;<br>            <span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>        &#125;,<br>        <span class="hljs-attr">scope2</span>: <span class="hljs-string">&#x27;local scope&#x27;</span><br>    &#125;,<br>    <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>, [[<span class="hljs-title class_">Scope</span>]]]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span> = [<br>  globalContext<br>];<br></code></pre></td></tr></table></figure>
<h1 id="6-this"><a href="#6-this" class="headerlink" title="6. this"></a>6. this</h1><p>对于每个执行上下文，都有三个重要属性<br>● 变量对象(Variable object，VO)<br>● 作用域链(Scope chain)<br>● this<br>本节主要讲this</p>
<h2 id="6-1-Types"><a href="#6-1-Types" class="headerlink" title="6.1. Types"></a>6.1. Types</h2><p>Types are further subclassified into ECMAScript language types and specification types.<br>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.<br>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record.<br>我们简单的翻译一下：<br>ECMAScript 的类型分为语言类型和规范类型。<br>ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。<br>而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。<br>我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。<br>这里要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。</p>
<h2 id="6-2-Reference"><a href="#6-2-Reference" class="headerlink" title="6.2. Reference"></a>6.2. Reference</h2><p>那什么又是 Reference ？<br>The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.<br>所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。<br>这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。<br>再看接下来的这段具体介绍 Reference 的内容：<br>A Reference is a resolved name binding.<br>A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.<br>The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).<br>A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.<br>这段讲述了 Reference 的构成，由三个组成部分，分别是：<br>● base value；<br>● referenced name；<br>● strict reference；<br>可是这些到底是什么呢？<br>我们简单的理解的话：<br>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。<br>referenced name 就是属性的名称。<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 对应的Reference是：</span><br><span class="hljs-keyword">var</span> fooReference = &#123;<br>    <span class="hljs-attr">base</span>: <span class="hljs-title class_">EnvironmentRecord</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>    <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span><br>&#125;;<br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>&#125;;<br> <br>foo.<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// foo</span><br><br><span class="hljs-comment">// bar对应的Reference是：</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">BarReference</span> = &#123;<br>    <span class="hljs-attr">base</span>: foo,<br>    <span class="hljs-attr">propertyName</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p>
<h3 id="6-2-1-GetBase"><a href="#6-2-1-GetBase" class="headerlink" title="6.2.1. GetBase"></a>6.2.1. GetBase</h3><p>GetBase(V). Returns the base value component of the reference V.<br>返回 reference 的 base value。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> fooReference = &#123;<br>    <span class="hljs-attr">base</span>: <span class="hljs-title class_">EnvironmentRecord</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>    <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span><br>&#125;;<br><br><span class="hljs-title class_">GetValue</span>(fooReference) <span class="hljs-comment">// 1;</span><br></code></pre></td></tr></table></figure>
<p>GetValue 返回对象属性真正的值，但是，调用 GetValue，返回的将是具体的值，而不再是一个 Reference</p>
<h3 id="6-2-2-IsPropertyReference"><a href="#6-2-2-IsPropertyReference" class="headerlink" title="6.2.2. IsPropertyReference"></a>6.2.2. IsPropertyReference</h3><p>IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.<br>如果 base value 是一个对象，就返回true。</p>
<h2 id="6-3-如何确定this的值"><a href="#6-3-如何确定this的值" class="headerlink" title="6.3. 如何确定this的值"></a>6.3. 如何确定this的值</h2><p>关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？<br>● Let ref be the result of evaluating MemberExpression；<br>● if Type(ref) is Reference, then<br>  ○ If IsPropertyReference(ref) is true, then<br>  ○ Let thisValue be GetBase(ref).<br>● Else, the base of ref is an Environment Record<br>  ○ Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref).<br>● Else, Type(ref) is not Reference.<br>● Let thisValue be undefined.<br>让我们描述一下：</p>
<ol>
<li>计算 MemberExpression 的结果赋值给 ref；</li>
<li>判断 ref 是不是一个 Reference 类型；<br>a. 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)<br>b. 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)<br>c. 如果 ref 不是 Reference，那么 this 的值为 undefined；</li>
</ol>
<h2 id="6-4-具体分析"><a href="#6-4-具体分析" class="headerlink" title="6.4. 具体分析"></a>6.4. 具体分析</h2><h3 id="6-4-1-计算-MemberExpression-的结果赋值给-ref"><a href="#6-4-1-计算-MemberExpression-的结果赋值给-ref" class="headerlink" title="6.4.1. 计算 MemberExpression 的结果赋值给 ref"></a>6.4.1. 计算 MemberExpression 的结果赋值给 ref</h3><p>什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions：<br>MemberExpression :<br>● PrimaryExpression // 原始表达式<br>● FunctionExpression // 函数定义表达式<br>● MemberExpression [ Expression ] // 属性访问表达式<br>● MemberExpression . IdentifierName // 属性访问表达式<br>● new MemberExpression Arguments // 对象创建表达式<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// MemberExpression 是 foo</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">foo</span>()(); <span class="hljs-comment">// MemberExpression 是 foo()</span><br><br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>&#125;<br><br>foo.<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// MemberExpression 是 foo.bar</span><br></code></pre></td></tr></table></figure>
<p>所以简单理解 MemberExpression 其实就是()左边的部分。</p>
<h3 id="6-4-2-判断-ref-是不是一个-Reference-类型。"><a href="#6-4-2-判断-ref-是不是一个-Reference-类型。" class="headerlink" title="6.4.2. 判断 ref 是不是一个 Reference 类型。"></a>6.4.2. 判断 ref 是不是一个 Reference 类型。</h3><p>关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//示例1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-title function_">bar</span>());<br><span class="hljs-comment">//示例2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((foo.<span class="hljs-property">bar</span>)());<br><span class="hljs-comment">//示例3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((foo.<span class="hljs-property">bar</span> = foo.<span class="hljs-property">bar</span>)());<br><span class="hljs-comment">//示例4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">false</span> || foo.<span class="hljs-property">bar</span>)());<br><span class="hljs-comment">//示例5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((foo.<span class="hljs-property">bar</span>, foo.<span class="hljs-property">bar</span>)());<br></code></pre></td></tr></table></figure>
<h3 id="6-4-3-foo-bar"><a href="#6-4-3-foo-bar" class="headerlink" title="6.4.3. foo.bar()"></a>6.4.3. foo.bar()</h3><p>上面的demo种，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？<br>根据规范，这里展示了一个计算的过程，什么都不管了，就看最后一步：<br>Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict.<br>我们得知该表达式返回了一个 Reference 类型<br>根据之前的内容，我们知道该值为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Reference</span> = &#123;   <span class="hljs-attr">base</span>: foo,   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,   <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span> &#125;;<br></code></pre></td></tr></table></figure>
<p>接下来按照流程：</p>
<ol>
<li>如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)<br>该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？<br>前面我们说了IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。<br>base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。<br>这个时候我们就可以确定 this 的值：<br>this = GetBase(ref)，<br>GetBase 也已经铺垫了，获得 base value 值，这个例子中就是fo，所以 this 的值就是 foo ，示例1的结果就是 2。<h3 id="6-4-4-foo-bar"><a href="#6-4-4-foo-bar" class="headerlink" title="6.4.4. (foo.bar)()"></a>6.4.4. (foo.bar)()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((foo.<span class="hljs-property">bar</span>)());<br></code></pre></td></tr></table></figure>
foo.bar 被 () 包住<br>Return the result of evaluating Expression. This may be of type Reference.<br>NOTE This algorithm does not apply GetValue to the result of evaluating Expression.<br>实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。<h3 id="6-4-5-foo-bar-foo-bar"><a href="#6-4-5-foo-bar-foo-bar" class="headerlink" title="6.4.5. (foo.bar = foo.bar)()"></a>6.4.5. (foo.bar = foo.bar)()</h3>看示例3，有赋值操作符，<br>因为使用了 GetValue，所以返回的值不是 Reference 类型，<br>按照之前讲的判断逻辑，如果 ref 不是Reference，那么 this 的值为 undefined<br>this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。<h3 id="6-4-6-false-foo-bar"><a href="#6-4-6-false-foo-bar" class="headerlink" title="6.4.6. (false || foo.bar)()"></a>6.4.6. (false || foo.bar)()</h3>示例4，因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined。<h3 id="6-4-7-foo-bar-foo-bar"><a href="#6-4-7-foo-bar-foo-bar" class="headerlink" title="6.4.7. (foo.bar, foo.bar)()"></a>6.4.7. (foo.bar, foo.bar)()</h3>看示例5，因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined。<h3 id="6-4-8-总结"><a href="#6-4-8-总结" class="headerlink" title="6.4.8. 总结"></a>6.4.8. 总结</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//示例1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-title function_">bar</span>()); <span class="hljs-comment">// 2</span><br><span class="hljs-comment">//示例2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((foo.<span class="hljs-property">bar</span>)()); <span class="hljs-comment">// 2</span><br><span class="hljs-comment">//示例3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((foo.<span class="hljs-property">bar</span> = foo.<span class="hljs-property">bar</span>)()); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//示例4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">false</span> || foo.<span class="hljs-property">bar</span>)()); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//示例5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((foo.<span class="hljs-property">bar</span>, foo.<span class="hljs-property">bar</span>)()); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。</li>
</ol>
<h1 id="7-执行上下文"><a href="#7-执行上下文" class="headerlink" title="7. 执行上下文"></a>7. 执行上下文</h1><h2 id="7-1-思考题"><a href="#7-1-思考题" class="headerlink" title="7.1. 思考题"></a>7.1. 思考题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-title function_">checkscope</span>()();<br></code></pre></td></tr></table></figure>
<p>两段代码都会打印’local scope’，在上文讲到了两者的区别在于执行上下文栈的变化不一样，本节会在此基础上，详细的解析执行上下文栈和执行上下文的具体变化过程。</p>
<h2 id="7-2-具体执行分析"><a href="#7-2-具体执行分析" class="headerlink" title="7.2. 具体执行分析"></a>7.2. 具体执行分析</h2><p>我们分析第一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br></code></pre></td></tr></table></figure>
<p>执行过程如下：<br>1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span> = [<br>     globalContext<br> ];<br></code></pre></td></tr></table></figure>
<p>2.全局上下文初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">globalContext = &#123;<br>    <span class="hljs-attr">VO</span>: [<span class="hljs-variable language_">global</span>],<br>    <span class="hljs-title class_">Scope</span>: [globalContext.<span class="hljs-property">VO</span>],<br>    <span class="hljs-attr">this</span>: globalContext.<span class="hljs-property">VO</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscope.[[scope]] = [<br>  globalContext.<span class="hljs-property">VO</span><br>];<br></code></pre></td></tr></table></figure></li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span> = [<br>    checkscopeContext,<br>    globalContext<br>];<br></code></pre></td></tr></table></figure></li>
<li>checkscope 函数执行上下文初始化：<br>a. 复制函数 [[scope]] 属性创建作用域链；<br>b. 用 arguments 创建活动对象；<br>c. 初始化活动对象，即加入形参、函数声明、变量声明；<br>d. 将活动对象压入 checkscope 作用域链顶端；<br>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscopeContext = &#123;<br>    <span class="hljs-attr">AO</span>: &#123;<br>        <span class="hljs-attr">arguments</span>: &#123;<br>            <span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>        &#125;,<br>        <span class="hljs-attr">scope</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">f</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;&#125;<br>    &#125;,<br>    <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>, globalContext.<span class="hljs-property">VO</span>],<br>    <span class="hljs-attr">this</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值；</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span> = [<br>    checkscopeContext,<br>    globalContext<br>];<br></code></pre></td></tr></table></figure></li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ECStack</span> = [<br>    globalContext<br>];<br></code></pre></td></tr></table></figure></li>
<li> 闭包<br>MDN 对闭包的定义为：<br>闭包是指那些能够访问自由变量的函数。<br>那什么是自由变量呢？<br>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。<br>由此，我们可以看出闭包共有两部分组成：<br>闭包 = 函数 + 函数能够访问的自由变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure>
foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。<br>所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。<br>但是，这是理论上的闭包，其实还有一个实践角度上的闭包。<br>ECMAScript中，闭包指的是：</li>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域；</li>
<li>从实践角度：以下函数才算是闭包：<br>a. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）；<br>b. 在代码中引用了自由变量；<br>接下来就来讲讲实践上的闭包。</li>
</ol>
<h1 id="8-分析"><a href="#8-分析" class="headerlink" title="8. 分析"></a>8. 分析</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-title function_">checkscope</span>();<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure>
<p>先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。<br>这里直接给出简要的执行过程：</p>
<ol>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈；</li>
<li>全局执行上下文初始化；</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈；</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等；</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出；</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈；</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this等；</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出；<br>了解到这个过程，我们应该思考一个问题：</li>
<li>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？<br>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fContext = &#123;<br>    <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>, checkscopeContext.<span class="hljs-property">AO</span>, globalContext.<span class="hljs-property">VO</span>],<br>&#125;<br></code></pre></td></tr></table></figure>
因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。<br>所以，让我们再看一遍实践角度上闭包的定义：</li>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）；</li>
<li>在代码中引用了自由变量；</li>
</ol>
<h2 id="14-2-思考题"><a href="#14-2-思考题" class="headerlink" title="14.2. 思考题"></a>14.2. 思考题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br></code></pre></td></tr></table></figure>
<p>答案是都是 3，让我们分析一下原因：<br>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">globalContext = &#123;<br>    <span class="hljs-attr">VO</span>: &#123;<br>        <span class="hljs-attr">data</span>: [...],<br>        <span class="hljs-attr">i</span>: <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">data[<span class="hljs-number">0</span>]<span class="hljs-title class_">Context</span> = &#123;<br>    <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>, globalContext.<span class="hljs-property">VO</span>]<br>&#125;<br>data[<span class="hljs-number">0</span>]<span class="hljs-title class_">Context</span> 的 <span class="hljs-variable constant_">AO</span> 并没有 i 值，所以会从 globalContext.<span class="hljs-property">VO</span> 中查找，i 为 <span class="hljs-number">3</span>，所以打印的结果就是 <span class="hljs-number">3</span>。<br>data[<span class="hljs-number">1</span>] 和 data[<span class="hljs-number">2</span>] 是一样的道理。<br></code></pre></td></tr></table></figure>
<p>所以改成闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = (<span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>        &#125;<br>  &#125;)(i);<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br></code></pre></td></tr></table></figure>
<p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">globalContext = &#123;<br>    <span class="hljs-attr">VO</span>: &#123;<br>        <span class="hljs-attr">data</span>: [...],<br>        <span class="hljs-attr">i</span>: <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>跟没改之前一模一样。<br>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">data[<span class="hljs-number">0</span>]<span class="hljs-title class_">Context</span> = &#123;<br>    <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>, 匿名函数<span class="hljs-title class_">Context</span>.<span class="hljs-property">AO</span> globalContext.<span class="hljs-property">VO</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>匿名函数执行上下文的AO为：<br>匿名函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Context</span> = &#123;<br>    <span class="hljs-attr">AO</span>: &#123;<br>        <span class="hljs-attr">arguments</span>: &#123;<br>            <span class="hljs-number">0</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>        &#125;,<br>        <span class="hljs-attr">i</span>: <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。<br>data[1] 和 data[2] 是一样的道理。</p>
<h1 id="9-参数按值传递"><a href="#9-参数按值传递" class="headerlink" title="9. 参数按值传递"></a>9. 参数按值传递</h1><p>在《JavaScript高级程序设计》中提到传递参数：<br>ECMAScript中所有函数的参数都是按值传递的。<br>什么是按值传递呢？<br>把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。</p>
<h2 id="15-1-按值传递"><a href="#15-1-按值传递" class="headerlink" title="15.1. 按值传递"></a>15.1. 按值传递</h2><p>举个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">v</span>) &#123;<br>    v = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(value);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<p>很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，函数中修改的都是 _value 的值，而不会影响原来的 value 值。</p>
<h2 id="15-2-共享传递"><a href="#15-2-共享传递" class="headerlink" title="15.2. 共享传递"></a>15.2. 共享传递</h2><p>拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝会产生性能上的问题。<br>这里提及一种：按引用传递。<br>所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">o</span>) &#123;<br>    o.<span class="hljs-property">value</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">value</span>); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>
<p>为什么《JavaScript高级程序设计》都说了 ECMAScript 中所有函数的参数都是按值传递的，那为什么能按”引用传递”成功呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">o</span>) &#123;<br>    o = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<p>如果 JavaScript 采用的是引用传递，外层的值也会被修改，那这里如何解释？<br>这就要讲到第二种传递方式，叫按共享传递。<br>而共享传递是指，在传递对象的时候，传递的是地址索引。<br>所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。<br>最后，你可以这样理解：<br>参数如果是基本类型是按值传递，如果是引用类型按共享传递。<br>但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。<br>换句话说，函数传递参数 ，传递的是参数的拷贝：</p>
<ol>
<li>指针拷贝，拷贝的是地址索引；</li>
<li>常规类型拷贝，拷贝的是值 ；<br>所以，一共是两种传递方式，按值传递和按共享传递。</li>
</ol>
<h2 id="15-3-总结"><a href="#15-3-总结" class="headerlink" title="15.3. 总结"></a>15.3. 总结</h2><p>javascript中数据类型分为基本类型与引用类型：</p>
<ol>
<li>基本类型值存储于栈内存中，传递的就是当前值，修改不会影响原有变量的值；</li>
<li>引用类型值其实也存于栈内存中，只是它的值是指向堆内存当中实际值的一个地址；索引引用传递传的值是栈内存当中的引用地址，当改变时，改变了堆内存当中的实际值；<br>所以针对上述的内容：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">v</span>) &#123;<br>    v = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(value);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>内存分布：<br>改变前：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th></th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>改变后：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th></th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td>2</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">o</span>) &#123;<br>    o.<span class="hljs-property">value</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">value</span>); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>
<p>改变前：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th></th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>指针地址</td>
<td>{value: 1}</td>
<td></td>
</tr>
<tr>
<td>o</td>
<td>指针地址</td>
<td>{value: 1}</td>
<td></td>
</tr>
</tbody></table>
<p>改变后：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th></th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>指针地址</td>
<td>{value: 2}</td>
<td></td>
</tr>
<tr>
<td>o</td>
<td>指针地址</td>
<td>{value: 2}</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">o</span>) &#123;<br>    o = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>改变前：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th></th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>指针地址</td>
<td>{value: 2}</td>
<td></td>
</tr>
<tr>
<td>o</td>
<td>指针地址</td>
<td>{value: 2}</td>
<td></td>
</tr>
</tbody></table>
<p>改变后：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th></th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>指针地址</td>
<td>{value: 2}</td>
<td></td>
</tr>
<tr>
<td>o</td>
<td>2</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="10-手写-call和-apply"><a href="#10-手写-call和-apply" class="headerlink" title="10. 手写 call和 apply"></a>10. 手写 call和 apply</h1><h2 id="10-1-手写call"><a href="#10-1-手写call" class="headerlink" title="10.1. 手写call"></a>10.1. 手写call</h2><p>call() ：在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br>bar.<span class="hljs-title function_">call</span>(foo); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>注意两点：</p>
<ol>
<li>call 改变了 this 的指向，指向到 foo；</li>
<li>bar 函数执行了；</li>
<li><h3 id="10-1-1-第一步"><a href="#10-1-1-第一步" class="headerlink" title="10.1.1. 第一步"></a>10.1.1. 第一步</h3>上述方式等同于：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;;<br><br>foo.<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
这个时候 this 就指向了 foo，但是这样却给 foo 对象本身添加了一个属性，所以们用 delete 再删除它即可。<br>所以我们模拟的步骤可以分为：</li>
<li>将函数设为对象的属性；</li>
<li>执行该函数；</li>
<li>删除该函数；<br>以上个例子为例，就是：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一步</span><br><span class="hljs-comment">// fn 是对象的属性名，反正最后也要删除它，所以起什么都可以。</span><br>foo.<span class="hljs-property">fn</span> = bar<br><span class="hljs-comment">// 第二步</span><br>foo.<span class="hljs-title function_">fn</span>()<br><span class="hljs-comment">// 第三步</span><br><span class="hljs-keyword">delete</span> foo.<span class="hljs-property">fn</span><br></code></pre></td></tr></table></figure>
根据上述思路，提供一版：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一版</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-comment">// 首先要获取调用call的函数，用this可以获取</span><br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>    context.<span class="hljs-title function_">fn</span>();<br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>&#125;<br><br><span class="hljs-comment">// 测试一下</span><br> <span class="hljs-keyword">let</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br>bar.<span class="hljs-title function_">call2</span>(foo); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<h3 id="10-1-2-第二步"><a href="#10-1-2-第二步" class="headerlink" title="10.1.2. 第二步"></a>10.1.2. 第二步</h3>call除了可以指定this，还可以指定参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br>bar.<span class="hljs-title function_">call</span>(foo, <span class="hljs-string">&#x27;kevin&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// kevin</span><br><span class="hljs-comment">// 18</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。<br>上述代码的Arguments中取第二个到最后一个的参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以上个例子为例，此时的arguments为：</span><br><span class="hljs-comment">// arguments = &#123;</span><br><span class="hljs-comment">//      0: foo,</span><br><span class="hljs-comment">//      1: &#x27;kevin&#x27;,</span><br><span class="hljs-comment">//      2: 18,</span><br><span class="hljs-comment">//      length: 3</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 因为arguments是类数组对象，所以可以用for循环</span><br><span class="hljs-keyword">var</span> args = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>    args.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 执行后 args为 [&quot;arguments[1]&quot;, &quot;arguments[2]&quot;, &quot;arguments[3]&quot;]</span><br></code></pre></td></tr></table></figure>
接下来使用eval拼接成一个函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args +<span class="hljs-string">&#x27;)&#x27;</span>)<br></code></pre></td></tr></table></figure>
考虑到目前大部分浏览器在console中限制eval的执行，也可以使用rest<br>此处代码为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第二版</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> arg = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>    context.<span class="hljs-title function_">fn</span>(...arg)<br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>&#125;<br><br><span class="hljs-comment">// 测试一下</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br>bar.<span class="hljs-title function_">call2</span>(foo, <span class="hljs-string">&#x27;kevin&#x27;</span>, <span class="hljs-number">18</span>); <br><span class="hljs-comment">// kevin</span><br><span class="hljs-comment">// 18</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<h3 id="10-1-3-第三步"><a href="#10-1-3-第三步" class="headerlink" title="10.1.3. 第三步"></a>10.1.3. 第三步</h3></li>
<li>this 参数可以传 null，当为 null 的时候，视为指向 window<br>举个例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br>bar.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li>
<li>针对函数，可以实现返回值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">age</span>: age<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">&#x27;kevin&#x27;</span>, <span class="hljs-number">18</span>));<br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//    value: 1,</span><br><span class="hljs-comment">//    name: &#x27;kevin&#x27;,</span><br><span class="hljs-comment">//    age: 18</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>
这里<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第三版</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>		<span class="hljs-keyword">var</span> context = context || <span class="hljs-variable language_">window</span>;<br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">let</span> arg = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> result = context.<span class="hljs-title function_">fn</span>(...arg)<br><br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>  	<span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">// 测试一下</span><br><span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">age</span>: age<br>    &#125;<br>&#125;<br><br>bar.<span class="hljs-title function_">call2</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 2</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-title function_">call2</span>(obj, <span class="hljs-string">&#x27;kevin&#x27;</span>, <span class="hljs-number">18</span>));<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//    value: 1,</span><br><span class="hljs-comment">//    name: &#x27;kevin&#x27;,</span><br><span class="hljs-comment">//    age: 18</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>
这边给出最简化的写法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) &#123;<br>  <span class="hljs-comment">// 判断是否是undefined和null</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context === <span class="hljs-string">&#x27;undefined&#x27;</span> || context === <span class="hljs-literal">null</span>) &#123;<br>    context = <span class="hljs-variable language_">window</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> fnSymbol = <span class="hljs-title class_">Symbol</span>()<br>  context[fnSymbol] = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">let</span> fn = context[fnSymbol](...args)<br>  <span class="hljs-keyword">delete</span> context[fnSymbol] <br>  <span class="hljs-keyword">return</span> fn<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="10-2-手写apply"><a href="#10-2-手写apply" class="headerlink" title="10.2. 手写apply"></a>10.2. 手写apply</h2><p>apply 的实现跟 call 类似，只是入参不一样，apply为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, arr</span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-title class_">Object</span>(context) || <span class="hljs-variable language_">window</span>;<br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">var</span> result;<br>    <span class="hljs-keyword">if</span> (!arr) &#123;<br>        result = context.<span class="hljs-title function_">fn</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>				result = context.<span class="hljs-title function_">fn</span>(...arr)<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最简化版方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, args</span>) &#123;<br>  <span class="hljs-comment">// 判断是否是undefined和null</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context === <span class="hljs-string">&#x27;undefined&#x27;</span> || context === <span class="hljs-literal">null</span>) &#123;<br>    context = <span class="hljs-variable language_">window</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> fnSymbol = <span class="hljs-title class_">Symbol</span>()<br>  context[fnSymbol] = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">let</span> fn = context[fnSymbol](...args)<br>  <span class="hljs-keyword">delete</span> context[fnSymbol] <br>  <span class="hljs-keyword">return</span> fn<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="11-手写-bind"><a href="#11-手写-bind" class="headerlink" title="11. 手写 bind"></a>11. 手写 bind</h1><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。<br>由此我们可以首先得出 bind 函数的两个特点：</p>
<ol>
<li>返回一个函数；</li>
<li>可以传入参数；</li>
</ol>
<h2 id="11-1-返回函数的模拟实现"><a href="#11-1-返回函数的模拟实现" class="headerlink" title="11.1. 返回函数的模拟实现"></a>11.1. 返回函数的模拟实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回了一个函数</span><br><span class="hljs-keyword">var</span> bindFoo = bar.<span class="hljs-title function_">bind</span>(foo); <br><br><span class="hljs-title function_">bindFoo</span>(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一版</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-comment">// 虑到绑定函数可能是有返回值的，加上return</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(context);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="11-2-传参的模拟实现"><a href="#11-2-传参的模拟实现" class="headerlink" title="11.2. 传参的模拟实现"></a>11.2. 传参的模拟实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">接下来，关于参数的传递：<br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<br><br>&#125;<br><br><span class="hljs-keyword">var</span> bindFoo = bar.<span class="hljs-title function_">bind</span>(foo, <span class="hljs-string">&#x27;daisy&#x27;</span>);<br><span class="hljs-title function_">bindFoo</span>(<span class="hljs-string">&#x27;18&#x27;</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// daisy</span><br><span class="hljs-comment">// 18</span><br></code></pre></td></tr></table></figure>
<p>当需要传 name 和 age 两个参数时，可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age。<br>这里如果不适用rest，使用arguments进行处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第二版</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br><br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 获取bind2函数从第二个参数到最后一个参数</span><br>    <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 这个时候的arguments是指bind返回的函数传入的参数</span><br>        <span class="hljs-keyword">var</span> bindArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(context, args.<span class="hljs-title function_">concat</span>(bindArgs));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="11-3-构造函数效果的模拟实现"><a href="#11-3-构造函数效果的模拟实现" class="headerlink" title="11.3. 构造函数效果的模拟实现"></a>11.3. 构造函数效果的模拟实现</h2><p>bind 还有一个特点，就是<br>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。<br>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">habit</span> = <span class="hljs-string">&#x27;shopping&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<br>&#125;<br><br>bar.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">friend</span> = <span class="hljs-string">&#x27;kevin&#x27;</span>;<br><br><span class="hljs-keyword">var</span> bindFoo = bar.<span class="hljs-title function_">bind</span>(foo, <span class="hljs-string">&#x27;daisy&#x27;</span>);<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bindFoo</span>(<span class="hljs-string">&#x27;18&#x27;</span>);<br><span class="hljs-comment">// undefined</span><br><span class="hljs-comment">// daisy</span><br><span class="hljs-comment">// 18</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">habit</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">friend</span>);<br><span class="hljs-comment">// shopping</span><br><span class="hljs-comment">// kevin</span><br></code></pre></td></tr></table></figure>
<p>尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了<br>后文中new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第三版</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">var</span> fBound = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> bindArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span><br>        <span class="hljs-comment">// 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span><br>        <span class="hljs-comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span><br>        <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> fBound ? <span class="hljs-variable language_">this</span> : context, args.<span class="hljs-title function_">concat</span>(bindArgs));<br>    &#125;<br>    <span class="hljs-comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span><br>    fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-keyword">return</span> fBound;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="11-4-构造函数效果的优化实现"><a href="#11-4-构造函数效果的优化实现" class="headerlink" title="11.4. 构造函数效果的优化实现"></a>11.4. 构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第四版</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br><br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">var</span> fNOP = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br><br>    <span class="hljs-keyword">var</span> fBound = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> bindArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> fNOP ? <span class="hljs-variable language_">this</span> : context, args.<span class="hljs-title function_">concat</span>(bindArgs));<br>    &#125;<br><br>    fNOP.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fNOP</span>();<br>    <span class="hljs-keyword">return</span> fBound;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="11-5-最终版"><a href="#11-5-最终版" class="headerlink" title="11.5. 最终版"></a>11.5. 最终版</h2><p>调用 bind 的不是函数时，提示错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终代码为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">var</span> fNOP = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br><br>    <span class="hljs-keyword">var</span> fBound = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> bindArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> fNOP ? <span class="hljs-variable language_">this</span> : context, args.<span class="hljs-title function_">concat</span>(bindArgs));<br>    &#125;<br><br>    fNOP.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fNOP</span>();<br>    <span class="hljs-keyword">return</span> fBound;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最简化版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br><span class="hljs-comment">// 判断是否是undefined 和 null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context === <span class="hljs-string">&quot;undefined&quot;</span> || context === <span class="hljs-literal">null</span>) &#123;<br>    	context = <span class="hljs-variable language_">window</span>;<br>    &#125;<br>    self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    	<span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="12-手写模拟-new"><a href="#12-手写模拟-new" class="headerlink" title="12. 手写模拟 new"></a>12. 手写模拟 new</h1><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一<br>先看看 new 实现了哪些功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name, age) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">habit</span> = <span class="hljs-string">&#x27;Games&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">strength</span> = <span class="hljs-number">80</span>;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayYourName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Kevin&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>) <span class="hljs-comment">// Kevin</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">habit</span>) <span class="hljs-comment">// Games</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">strength</span>) <span class="hljs-comment">// 60</span><br><br>person.<span class="hljs-title function_">sayYourName</span>(); <span class="hljs-comment">// I am Kevin</span><br></code></pre></td></tr></table></figure>
<p>我们可以看到，实例 person 可以：</p>
<ol>
<li>访问到 Otaku 构造函数里的属性；</li>
<li>访问到 Otaku.prototype 中的属性；<br>接下来，我们可以尝试着模拟一下了。<br>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> () &#123;<br>    ……<br>&#125;<br><br><span class="hljs-comment">// 使用 new</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(……);<br><span class="hljs-comment">// 使用 objectFactory</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-title function_">objectFactory</span>(<span class="hljs-title class_">Person</span>, ……)<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-1-初步实现"><a href="#12-1-初步实现" class="headerlink" title="12.1. 初步实现"></a>12.1. 初步实现</h2><p>因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Person 构造函数里的属性，我们可以使用 Person.apply(obj, arguments)来给 obj 添加新的属性。<br>然后，实例的 <strong>proto</strong> 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一版代码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(),<br>    <span class="hljs-title class_">Constructor</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br><br>    <span class="hljs-keyword">return</span> obj;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这一版中，我们：</p>
<ol>
<li>用new Object() 的方式新建了一个对象 obj；</li>
<li>取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数；</li>
<li>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性；</li>
<li>使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性；</li>
<li>返回 obj；<br>测试下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name, age) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">habit</span> = <span class="hljs-string">&#x27;Games&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">strength</span> = <span class="hljs-number">60</span>;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayYourName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(),<br>    <span class="hljs-title class_">Constructor</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-title function_">objectFactory</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">&#x27;Kevin&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>) <span class="hljs-comment">// Kevin</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">habit</span>) <span class="hljs-comment">// Games</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">strength</span>) <span class="hljs-comment">// 60</span><br><br>person.<span class="hljs-title function_">sayYourName</span>(); <span class="hljs-comment">// I am Kevin</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-2-最终实现"><a href="#12-2-最终实现" class="headerlink" title="12.2. 最终实现"></a>12.2. 最终实现</h2><p>假如构造函数有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name, age) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">strength</span> = <span class="hljs-number">60</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">habit</span>: <span class="hljs-string">&#x27;Games&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Kevin&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>) <span class="hljs-comment">// Kevin</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">habit</span>) <span class="hljs-comment">// Games</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">strength</span>) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。<br>而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？<br>再举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name, age) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">strength</span> = <span class="hljs-number">60</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;handsome boy&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Otaku</span>(<span class="hljs-string">&#x27;Kevin&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">habit</span>) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">strength</span>) <span class="hljs-comment">// 60</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>) <span class="hljs-comment">// 18</span><br></code></pre></td></tr></table></figure>
<p>这次尽管有返回值，但是相当于没有返回值进行处理。<br>所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 最终版的代码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(),<br>    <span class="hljs-title class_">Constructor</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-keyword">var</span> ret = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&#x27;object&#x27;</span> ? ret : obj;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="13-类数组对象与arguments"><a href="#13-类数组对象与arguments" class="headerlink" title="13. 类数组对象与arguments"></a>13. 类数组对象与arguments</h1><h2 id="13-1-类数组对象"><a href="#13-1-类数组对象" class="headerlink" title="13.1. 类数组对象"></a>13.1. 类数组对象</h2><p>所谓的类数组对象:<br>拥有一个 length 属性和若干索引属性的对象<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> array = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>];<br><br><span class="hljs-keyword">var</span> arrayLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="13-1-1-读写"><a href="#13-1-1-读写" class="headerlink" title="13.1.1. 读写"></a>13.1.1. 读写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[<span class="hljs-number">0</span>]); <span class="hljs-comment">// name</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrayLike[<span class="hljs-number">0</span>]); <span class="hljs-comment">// name</span><br><br>array[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;new name&#x27;</span>;<br>arrayLike[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;new name&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="13-1-2-长度"><a href="#13-1-2-长度" class="headerlink" title="13.1.2. 长度"></a>13.1.2. 长度</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrayLike.<span class="hljs-property">length</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<h3 id="13-1-3-遍历"><a href="#13-1-3-遍历" class="headerlink" title="13.1.3. 遍历"></a>13.1.3. 遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = array.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>   ……<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arrayLike.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是调用原生的数组方法会报错，如push：<br>arrayLike.push is not a function</p>
<h3 id="13-1-4-调用数组方法"><a href="#13-1-4-调用数组方法" class="headerlink" title="13.1.4. 调用数组方法"></a>13.1.4. 调用数组方法</h3><p>只能通过 Function.call 间接调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arrayLike = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span> &#125;<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">join</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-string">&#x27;&amp;&#x27;</span>); <span class="hljs-comment">// name&amp;age&amp;sex</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>); <span class="hljs-comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span><br><span class="hljs-comment">// slice可以做到类数组转数组</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;<br>    <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toUpperCase</span>();<br>&#125;); <br><span class="hljs-comment">// [&quot;NAME&quot;, &quot;AGE&quot;, &quot;SEX&quot;]</span><br></code></pre></td></tr></table></figure>

<h3 id="13-1-5-类数组转数组"><a href="#13-1-5-类数组转数组" class="headerlink" title="13.1.5. 类数组转数组"></a>13.1.5. 类数组转数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arrayLike = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span> &#125;<br><span class="hljs-comment">// 1. slice</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike); <span class="hljs-comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span><br><span class="hljs-comment">// 2. splice</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>); <span class="hljs-comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span><br><span class="hljs-comment">// 3. ES6 Array.from</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike); <span class="hljs-comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span><br><span class="hljs-comment">// 4. apply</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike)<br></code></pre></td></tr></table></figure>
<h2 id="13-2-Arguments对象"><a href="#13-2-Arguments对象" class="headerlink" title="13.2. Arguments对象"></a>13.2. Arguments对象</h2><p>Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age, sex</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>打印结果：</p>
<p>可以看到除了类数组的索引属性和length属性之外，还有一个callee属性</p>
<h3 id="13-2-1-length属性"><a href="#13-2-1-length属性" class="headerlink" title="13.2.1. length属性"></a>13.2.1. length属性</h3><p>Arguments对象的length属性，表示实参的长度，举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">b, c, d</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;实参的长度为：&quot;</span> + <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;形参的长度为：&quot;</span> + foo.<span class="hljs-property">length</span>)<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 形参的长度为：3</span><br><span class="hljs-comment">// 实参的长度为：1</span><br></code></pre></td></tr></table></figure>
<h3 id="13-2-2-callee属性"><a href="#13-2-2-callee属性" class="headerlink" title="13.2.2. callee属性"></a>13.2.2. callee属性</h3><p>Arguments 对象的 callee 属性，通过它可以调用函数自身。<br>讲个闭包经典面试题使用 callee 的解决方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    (data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">i</span>) <br>    &#125;).<span class="hljs-property">i</span> = i;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<h3 id="13-2-3-arguments-和对应参数的绑定"><a href="#13-2-3-arguments-和对应参数的绑定" class="headerlink" title="13.2.3. arguments 和对应参数的绑定"></a>13.2.3. arguments 和对应参数的绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age, sex, hobbit</span>) &#123;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// name name</span><br><br>    <span class="hljs-comment">// 改变形参</span><br>    name = <span class="hljs-string">&#x27;new name&#x27;</span>;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// new name new name</span><br><br>    <span class="hljs-comment">// 改变arguments</span><br>    <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;new age&#x27;</span>;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// new age new age</span><br><br>    <span class="hljs-comment">// 测试未传入的是否会绑定</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sex); <span class="hljs-comment">// undefined</span><br><br>    sex = <span class="hljs-string">&#x27;new sex&#x27;</span>;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sex, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>]); <span class="hljs-comment">// new sex undefined</span><br><br>    <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;new hobbit&#x27;</span>;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hobbit, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">3</span>]); <span class="hljs-comment">// undefined new hobbit</span><br><br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享</p>
<h3 id="13-2-4-传递参数"><a href="#13-2-4-传递参数" class="headerlink" title="13.2.4. 传递参数"></a>13.2.4. 传递参数</h3><p>将参数从一个函数传递到另一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 apply 将 foo 的参数传递给 bar</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    bar.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c);<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<h3 id="13-2-5-ES6"><a href="#13-2-5-ES6" class="headerlink" title="13.2.5. ES6"></a>13.2.5. ES6</h3><p>使用ES6的 … 运算符，我们可以轻松转成数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">...<span class="hljs-variable language_">arguments</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// [1, 2, 3]</span><br>&#125;<br><br><span class="hljs-title function_">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<h3 id="13-2-6-应用"><a href="#13-2-6-应用" class="headerlink" title="13.2.6. 应用"></a>13.2.6. 应用</h3><p>arguments的应用其实很多，像参数不定长、函数柯里化等等都有涉及。</p>
<h1 id="14-创建对象的多种方式-amp-优缺点"><a href="#14-创建对象的多种方式-amp-优缺点" class="headerlink" title="14. 创建对象的多种方式&amp;优缺点"></a>14. 创建对象的多种方式&amp;优缺点</h1><h2 id="14-1-工厂模式"><a href="#14-1-工厂模式" class="headerlink" title="14.1. 工厂模式"></a>14.1. 工厂模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    o.<span class="hljs-property">name</span> = name;<br>    o.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;kevin&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>优点：简单；<br>缺点：对象无法识别，因为所有的实例都指向一个原型；</p>
<h2 id="14-2-构造函数模式"><a href="#14-2-构造函数模式" class="headerlink" title="14.2. 构造函数模式"></a>14.2. 构造函数模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;kevin&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>优点：实例可以识别为一个特定的类型；<br>缺点：每次创建实例时，每个方法都要被创建一次；</p>
<h3 id="14-2-1-构造函数优化"><a href="#14-2-1-构造函数优化" class="headerlink" title="14.2.1. 构造函数优化"></a>14.2.1. 构造函数优化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = getName;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;kevin&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>解决了每个方法都要重新创建的问题</p>
<h2 id="14-3-原型模式"><a href="#14-3-原型模式" class="headerlink" title="14.3. 原型模式"></a>14.3. 原型模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br><br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zu be&#x27;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure>
<p>优点：方法不会重新创建；<br>缺点：</p>
<ol>
<li>所有的属性和方法都共享；</li>
<li>不能初始化参数；</li>
</ol>
<h3 id="14-3-1-原型模式优化"><a href="#14-3-1-原型模式优化" class="headerlink" title="14.3.1. 原型模式优化"></a>14.3.1. 原型模式优化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br><br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zube&#x27;</span>,<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure>
<p>优点：封装清晰点；<br>缺点：重写了原型，丢失了constructor属性；</p>
<h3 id="14-3-2-原型模式优化2"><a href="#14-3-2-原型模式优化2" class="headerlink" title="14.3.2.  原型模式优化2"></a>14.3.2.  原型模式优化2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br><br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kevin&#x27;</span>,<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure>
<p>优点：实例可以通过constructor属性找到所属构造函数；<br>缺点：</p>
<ol>
<li>所有的属性和方法都共享；</li>
<li>不能初始化参数；</li>
</ol>
<h2 id="14-4-组合模式"><a href="#14-4-组合模式" class="headerlink" title="14.4. 组合模式"></a>14.4. 组合模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure>
<p>优点：该共享的共享，该私有的私有，使用最广泛的方式；<br>缺点：希望写在一个地方，即更好的封装性；</p>
<h3 id="14-4-1-动态原型模式"><a href="#14-4-1-动态原型模式" class="headerlink" title="14.4.1. 动态原型模式"></a>14.4.1. 动态原型模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> != <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure>
<p>注意：使用动态原型模式时，不能用对象字面量重写原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> != <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>            <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>            <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zube&#x27;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;be zu&#x27;</span>);<br><br><span class="hljs-comment">// 报错 并没有该方法</span><br>person1.<span class="hljs-title function_">getName</span>();<br><br><span class="hljs-comment">// 注释掉上面的代码，这句是可以执行的。</span><br>person2.<span class="hljs-title function_">getName</span>();<br></code></pre></td></tr></table></figure>
<p>开始执行var person1 = new Person(‘zube’)<br>我们回顾下 new 的实现步骤：</p>
<ol>
<li>首先新建一个对象；</li>
<li>然后将对象的原型指向 Person.prototype；</li>
<li>然后 Person.apply(obj)；</li>
<li>返回这个对象；<br>注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了。<br>如果你就是想用字面量方式写代码，可以尝试下这种：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> != <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>            <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>            <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zube&#x27;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;bezu&#x27;</span>);<br><br>person1.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// zube</span><br>person2.<span class="hljs-title function_">getName</span>();  <span class="hljs-comment">// bezu</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="15-继承的多种方式-amp-优缺点"><a href="#15-继承的多种方式-amp-优缺点" class="headerlink" title="15. 继承的多种方式&amp;优缺点"></a>15. 继承的多种方式&amp;优缺点</h1><h2 id="15-1-原型链继承"><a href="#15-1-原型链继承" class="headerlink" title="15.1. 原型链继承"></a>15.1. 原型链继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zube&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span> () &#123;<br><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// zube</span><br></code></pre></td></tr></table></figure>

<p>问题：引用类型的属性被所有实例共享，举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">names</span> = [<span class="hljs-string">&#x27;zube&#x27;</span>, <span class="hljs-string">&#x27;bezu&#x27;</span>];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span> () &#123;<br><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br>child1.<span class="hljs-property">names</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">names</span>); <span class="hljs-comment">// [&quot;zube&quot;, &quot;bezu&quot;, &quot;test&quot;]</span><br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">names</span>); <span class="hljs-comment">// [&quot;zube&quot;, &quot;bezu&quot;, &quot;test&quot;]</span><br></code></pre></td></tr></table></figure>

<h2 id="15-2-借用构造函数"><a href="#15-2-借用构造函数" class="headerlink" title="15.2. 借用构造函数"></a>15.2. 借用构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">names</span> = [<span class="hljs-string">&#x27;zube&#x27;</span>, <span class="hljs-string">&#x27;bezu&#x27;</span>];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span> () &#123;<br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br>child1.<span class="hljs-property">names</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">names</span>); <span class="hljs-comment">// [&quot;zube&quot;, &quot;bezu&quot;, &quot;test&quot;]</span><br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">names</span>); <span class="hljs-comment">// [&quot;zube&quot;, &quot;bezu&quot;]</span><br></code></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>避免了引用类型的属性被所有实例共享；</li>
<li>可以在 Child 中向 Parent 传参；</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> (name) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span> (name) &#123;<br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>&#125;<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;zube&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">name</span>); <span class="hljs-comment">// zube</span><br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;bezu&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">name</span>); <span class="hljs-comment">// bezu</span><br></code></pre></td></tr></table></figure>
缺点：<br>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li>
</ol>
<h2 id="15-3-租合继承"><a href="#15-3-租合继承" class="headerlink" title="15.3. 租合继承"></a>15.3. 租合继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> (name) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span> (name, age) &#123;<br><br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;kevin&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>);<br><br>child1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">name</span>); <span class="hljs-comment">// kevin</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">age</span>); <span class="hljs-comment">// 18</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;daisy&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">name</span>); <span class="hljs-comment">// daisy</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">age</span>); <span class="hljs-comment">// 20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></code></pre></td></tr></table></figure>
<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<h2 id="15-4-原型继承"><a href="#15-4-原型继承" class="headerlink" title="15.4. 原型继承"></a>15.4. 原型继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObj</span>(<span class="hljs-params">o</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>缺点：<br>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kevin&#x27;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;daisy&#x27;</span>, <span class="hljs-string">&#x27;kelly&#x27;</span>]<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-title function_">createObj</span>(person);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-title function_">createObj</span>(person);<br><br>person1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;person1&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">name</span>); <span class="hljs-comment">// kevin</span><br><br>person1.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;taylor&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">friends</span>); <span class="hljs-comment">// [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br></code></pre></td></tr></table></figure>

<h2 id="15-5-寄生式继承"><a href="#15-5-寄生式继承" class="headerlink" title="15.5. 寄生式继承"></a>15.5. 寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObj</span> (o) &#123;<br>    <span class="hljs-keyword">var</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(o);<br>    clone.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JS/">#JS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JS高级用法</div>
      <div>http://example.com/2023/03/20/JS高级用法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zubeneschamali</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/17/ChatGPT-test/" title="ChatGPT-test">
                        <span class="hidden-mobile">ChatGPT-test</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
